/* * factory.c * --------- * This concurrent program is designed to simulate a simple widget factory.  * There are 26 "Worker" threads (one for each letter of the alphabet) * and each worker is builds a batch of 100 widgets, thus a total of * 2600 widgets will be built overall. Each time a Worker makes a widget,  * it updates the global count of the number of total widgets built. The * one "Supervisor" thread keeps an eye on this global counter and each time * it reaches a multiple of 100, the Supervisor prints an encouraging * messages to the workers to keep their productivity up. There is also * an array which keeps track of the names of the first 3 worker threads * that finish, and the supervisor announces those names after all the * widgets have been built at the end of the simulation. * * As it stands, the code has some definite problems.  It uses no semaphores * and makes no attempt to avoid contention for any globals accessed by * multiple threads.  Following the instructions on the handout, you will * observe the behavior of the buggy program and insert the necessary * semaphores to fix it until it runs perfectly every time. */ #include "thread_107.h"#include <stdio.h>#include <stdlib.h>#define NUM_WORKERS 26  // one for every letter in the alphabet#define NUM_WINNERS 3#define BATCH 100static void RandomDelay(int atLeastMicrosecs, int atMostMicrosecs);static void MakeWidget(void);static void Worker(void);static void Supervisor(void);static const char *winners[NUM_WINNERS] = {"Empty", "Empty", "Empty"};static int numWorkersDone = 0, numWidgetsMade = 0;/* * The main creates all the worker threads and the one supervisor * thread and then lets them run to completion.  They should all finish  * when the simulation is done. By running with the -v flag, it will  * include the trace output from the thread library. */int main(int argc, char **argv) {    int i;    char name[32];    bool verbose = (argc == 2 && (strcmp(argv[1], "-v") == 0));            InitThreadPackage(verbose);        for (i = 0; i < NUM_WORKERS; i++) {        sprintf(name, "Worker %c", i + 'A');        ThreadNew(name, Worker, 0);    }    ThreadNew("Supervisor", Supervisor, 0);    RunAllThreads();            // Let them all loose    return 0;}/*  * Supervisor * ---------- * This function is executed by one single Supervisor thread. The * Supervisor mostly just hangs out and watches the Workers toil away. * However, in order to keep everyone's productivity up, the supervisor * will note when each multiple of 100 widgets has been reached and * prints an encouraging message. Since each worker makes 100, this  * should happen NUM_WORKERS times.  After all the widgets have been * made, the supervisor reports who the top 3 finishers were and maybe * they get a nice raise. :-) */static void Supervisor(void) {    int i, target;        for (target = BATCH; target <= NUM_WORKERS*BATCH; target += BATCH) {          while (numWidgetsMade < target) ;   // wait for multiple of 100         printf("%s says: Good work, folks, we've made %d!\n",                                 ThreadName(), target);    }            printf("\n%s says: Super! We're done. The top finishers were:\n",             ThreadName());    for (i = 0; i < NUM_WINNERS; i++)       printf("  %d) %s\n", i + 1, winners[i]);}/*  * Worker * ------- * This function is executed by each of the 26 Worker threads.  Each * worker is chargedd with the task of creating 100 widgets (using the * MakeWidget function) and updating the global counter after each one. * When finishing making all 100 widget, the Worker also increments the * count of finished workers, and if one of the first few finishers, it * records its name in the list of winners. */static void Worker(void) {    int i;        for (i = 0; i < BATCH; i++) {        MakeWidget();        numWidgetsMade++;    }          /* When done, we want to increment counter of num finished workers,      * but only store name in list if we were one of the top finishers */    if (numWorkersDone++ < NUM_WINNERS)           winners[numWorkersDone-1] = ThreadName();    printf("%s DONE!\n", ThreadName());}/*  * MakeWidget * ---------- * Just inserts a random delay to vary execution patterns as a means * of simulating that the thread goes off and does some independent * activity here. */static void MakeWidget(void){    RandomDelay(5, 10);   // sleep random amount to simulate making pat}/*  * RandomDelay * ------------- * This is used to put the current thread to sleep for a little bit. * This function is already thread-safe and should require no modification. */static void RandomDelay(int atLeastMicrosecs, int atMostMicrosecs){    long choice;    int range = atMostMicrosecs - atLeastMicrosecs + 1;            choice = random();                        ThreadSleep(atLeastMicrosecs + choice % range); // put thread to sleep}