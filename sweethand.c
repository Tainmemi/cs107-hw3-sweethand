/* File: sweethand.c * ----------------- * This code concurrently fingers a bunch of users  * on a bunch of hosts and reports the results. */#include "thread_107.h"#include <stdio.h>#include <stdlib.h>#include <assert.h>#include "scanner.h"#include "network.h"#include <netdb.h>      // for MAXHOSTNAMELEN #include <limits.h>     // for LOGNAME_MAX #include <string.h>     // for strcasecmp#define MAX_THREADS 200#define MAX_HOSTS 100#define MAX_BUFFERS 20#define MAX_SOCKETS 5#define MAX_TRIES 4#define UNREACHABLE_THRESHHOLD 3#define RESULTS_EVERY 1000#define REALNAME_MAX 1024#define NOT_FOUND -1#define NET_ERR -1typedef struct {    Semaphore   lock;    bool        busy;           // set flag to control socket} Socket;typedef char Username[LOGNAME_MAX + 1];typedef enum {empty, ready, busy} Userstate;    typedef struct {	Semaphore	lock;	Username	name;	Userstate	state;          // can be empty, ready for processing, or busy processing	int         numThreads;     // number of finger threads using user buffer} User;typedef char Hostname[MAXHOSTNAMELEN + 1];typedef struct {	Semaphore	lock;	Hostname	name;	int			address;	int			numLogins;      // number of logins on host	int			numFailures;    // number of completely failed fingers on host} Host;typedef struct {	Semaphore		lock;	Semaphore		ready;      // signalled when host request is ready for processing	Semaphore		done;       // signalled when host request is done processing	Hostname		name;       // name of host for address request	int				address;    // address returned by host request} hostRequest;typedef struct {    Semaphore   lock;    Semaphore   ready;          // signalled when score report is ready for processing    Semaphore   done;           // signalled when score report is done processing    int         hostIndex;      // index of host which report refers to    int         numRetries;     // number of retries attempted by RetryFinger    int         fingerResult;   // result of finger is error or number of user's logins    bool		final;          // set flag to indicate current report is final} scoreReport;static Semaphore threadFree;    // signalled when thread exitsstatic struct {    Semaphore   free;           // signalled when a socket is free for requests    Socket      array[MAX_SOCKETS];} sweetSocket;static struct {	Semaphore	empty;          // signalled when a user buffer is empty	Semaphore	ready;          // signalled when a user buffer is ready for processing	Semaphore	done;           // signalled when a user buffer is done processing	User buffer[MAX_BUFFERS];} sweetUsers;static struct {	hostRequest		request;	scoreReport     report;	int             numHosts;	Host			array[MAX_HOSTS];} sweetHosts;static void ConcurrentFingerAll(const char *userfile, const char *hostfile);static void LookupNames(const char *userfile);static void DispatchFingers(const char *hostfile);static void ReadHosts(const char *hostfile);static void LookupHosts(int numHosts);static void RetryFinger(int userIndex, int hostIndex);static int FingerUser(char *username, int address, bool isRetry);static void ReportScores(void);static void PrintReport(int totalRequests, int failedRequests, bool final);static int HostCompare(const void *entry1, const void *entry2);/*  * main * ---- * The code here picks out the debug trace arguments * and sets the flags which you might find handy. */int main(int argc, char **argv) {    bool networkTrace = false, threadTrace = false;        if (argc >= 2 && argv[1][0] == '-') {    	if (strcmp(argv[1], "-t") == 0) threadTrace = true;      	if (strcmp(argv[1], "-n") == 0) networkTrace = true;    	if (strcmp(argv[1], "-tn") == 0) networkTrace = threadTrace = true;    	if (strcmp(argv[1], "-nt") == 0) networkTrace = threadTrace = true;	argv++;	// advance past the flag argument	argc--;    }    if (argc < 3) {        printf("\nOOPS!  This program takes two arguments: the file of users and the file of hostnames.\nPlease try again!\n\n");	exit(-1);    }    InitNetworkPackage(MAX_SOCKETS, networkTrace);        InitThreadPackage(threadTrace);    ConcurrentFingerAll(argv[1], argv[2]);    return 0;}/*  * ConcurrentFingerAll * ------------------- * The code here initializes all semaphores, starts LookupNames,  * DispatchFingers, and ReportScores, and frees all semaphores  * when the threads have finished. */static void ConcurrentFingerAll(const char *userfile, const char *hostfile){		int i;		threadFree = SemaphoreNew("Free Threads", MAX_THREADS);	sweetSocket.free = SemaphoreNew("Free Sockets", MAX_SOCKETS);	for (i = 0; i < MAX_SOCKETS; i++) {	    sweetSocket.array[i].lock = SemaphoreNew("Socket Lock", 1);	    sweetSocket.array[i].busy = false;	}	sweetUsers.empty = SemaphoreNew("Empty Buffers", MAX_BUFFERS);	sweetUsers.ready = SemaphoreNew("Ready Buffers", 0);	sweetUsers.done = SemaphoreNew("Done Buffers", 0);	for (i = 0; i < MAX_BUFFERS; i++) {		sweetUsers.buffer[i].lock = SemaphoreNew("Buffer Lock", 1);		sweetUsers.buffer[i].state = empty;	}	sweetHosts.request.lock = SemaphoreNew("Host Request Lock", 1);	sweetHosts.request.ready = SemaphoreNew("Host Request Ready", 0);	sweetHosts.request.done = SemaphoreNew("Host Request Done", 0);	sweetHosts.report.lock = SemaphoreNew("Score Report Lock", 1);	sweetHosts.report.ready = SemaphoreNew("Score Report Ready", 0);	sweetHosts.report.done = SemaphoreNew("Score Report Done", 0);		for (i = 0; i < MAX_HOSTS; i++) {	    sweetHosts.array[i].lock = SemaphoreNew("Host Lock", 1);	    sweetHosts.array[i].numLogins = 0;		sweetHosts.array[i].address = 0;		sweetHosts.array[i].numFailures = 0;	}	SemaphoreWait(threadFree);	ThreadNew("LookupNames", LookupNames, 1, userfile);	SemaphoreWait(threadFree);	ThreadNew("DispatchFingers", DispatchFingers, 1, hostfile);	SemaphoreWait(threadFree);	ThreadNew("ReportScores", ReportScores, 0);	RunAllThreads();	SemaphoreFree(threadFree);	SemaphoreFree(sweetSocket.free);	for (i = 0; i < MAX_SOCKETS; i++) {	    SemaphoreFree(sweetSocket.array[i].lock);	}	SemaphoreFree(sweetUsers.empty);	SemaphoreFree(sweetUsers.ready);	SemaphoreFree(sweetUsers.done);	for (i = 0; i < MAX_BUFFERS; i++) {	    SemaphoreFree(sweetUsers.buffer[i].lock);	}	SemaphoreFree(sweetHosts.request.lock);	SemaphoreFree(sweetHosts.request.ready);	SemaphoreFree(sweetHosts.request.done);	SemaphoreFree(sweetHosts.report.lock);	SemaphoreFree(sweetHosts.report.ready);	SemaphoreFree(sweetHosts.report.done);		for (i = 0; i < MAX_HOSTS; i++) {	    SemaphoreFree(sweetHosts.array[i].lock);	}}/*  * LookupNames * ----------- * The code here scans realnames from a file and finds valid usernames. * Then it waits for RetryFinger to signal that there are empty buffers. * After finding and readying the buffer, it signals DispatchFingers. */static void LookupNames(const char *userfile){	Scanner names;	char realname[REALNAME_MAX];	Username username;	int userIndex;		names = NewScannerFromFilename(userfile, "\n", true);	assert (names != NULL);		while (ReadNextToken(names, realname, sizeof(realname))) {		if (Whois(realname, username, sizeof(username))) {			SemaphoreWait(sweetUsers.empty);			for (userIndex = 0; userIndex < MAX_BUFFERS; userIndex++) {				SemaphoreWait(sweetUsers.buffer[userIndex].lock);				if (sweetUsers.buffer[userIndex].state == empty) {					strcpy(sweetUsers.buffer[userIndex].name, username);					sweetUsers.buffer[userIndex].state = ready;					SemaphoreSignal(sweetUsers.buffer[userIndex].lock);					SemaphoreSignal(sweetUsers.ready);					break;				}				SemaphoreSignal(sweetUsers.buffer[userIndex].lock);			}		}    }    SemaphoreSignal(sweetUsers.ready);  // signal DispatchFingers to scan empty array    FreeScanner(names);    SemaphoreSignal(threadFree);}/*  * DispatchFingers * --------------- * The code here gets the hosts and starts the LookupHosts thread. * Then it waits for LookupNames to signal that there are ready buffers. * After finding and busying the buffer, it dispatches a RetryFinger thread * for every host. After LookupNames is done, it waits for each RetryFinger * to signal that it's done before it submits the final stats to ReportScores. */static void DispatchFingers(const char *hostfile){	int userIndex, hostIndex, numUsers = 0;	    ReadHosts(hostfile);	SemaphoreWait(threadFree);	ThreadNew("LookupHosts", LookupHosts, 1, sweetHosts.numHosts);		do {		SemaphoreWait(sweetUsers.ready);		for (userIndex = 0; userIndex < MAX_BUFFERS; userIndex++) {			SemaphoreWait(sweetUsers.buffer[userIndex].lock);			if (sweetUsers.buffer[userIndex].state == ready) {				sweetUsers.buffer[userIndex].state = busy;				sweetUsers.buffer[userIndex].numThreads = sweetHosts.numHosts;				SemaphoreSignal(sweetUsers.buffer[userIndex].lock);				for (hostIndex = 0; hostIndex < sweetHosts.numHosts; hostIndex++) {					SemaphoreWait(threadFree);					ThreadNew("RetryFinger", RetryFinger, 2, userIndex, hostIndex);				}				numUsers++;				break;			}			SemaphoreSignal(sweetUsers.buffer[userIndex].lock);		}	} while (userIndex < MAX_BUFFERS);	// a complete pass through an empty array means we're done	    while (numUsers--) {							// for each username processed    	SemaphoreWait(sweetUsers.done);				// wait for last thread to finish	}    SemaphoreWait(sweetHosts.report.lock);    sweetHosts.report.final = true;	SemaphoreSignal(sweetHosts.report.ready);	SemaphoreWait(sweetHosts.report.done);	SemaphoreSignal(sweetHosts.report.lock);	SemaphoreSignal(threadFree);}/*  * ReadHosts * --------- * The code here scans hostnames from a file and increments numHosts. */static void ReadHosts(const char *hostfile){	Scanner hosts;	Hostname hostname;		hosts = NewScannerFromFilename(hostfile, "\n", true);	assert(hosts != NULL);	for (sweetHosts.numHosts = 0; ReadNextToken(hosts, hostname, sizeof(hostname)); sweetHosts.numHosts++) {	    assert(sweetHosts.numHosts < MAX_HOSTS);		SemaphoreWait(sweetHosts.array[sweetHosts.numHosts].lock);		strcpy(sweetHosts.array[sweetHosts.numHosts].name, hostname);		SemaphoreSignal(sweetHosts.array[sweetHosts.numHosts].lock);	}	assert(sweetHosts.numHosts > 0);    FreeScanner(hosts);}/*  * LookupHosts * ----------- * The code here waits for RetryFinger to signal for a host request. * It doesn't use the lock because RetryFinger has the request locked already. * It is done when all the hosts' addresses have been looked up. */static void LookupHosts(int numHosts) {	while (numHosts--) {		SemaphoreWait(sweetHosts.request.ready);		sweetHosts.request.address = LookupHostAddress(sweetHosts.request.name);		SemaphoreSignal(sweetHosts.request.done);	}	SemaphoreSignal(threadFree);}/*  * RetryFinger * ----------- * The code here obtains the address of the host with a host request, unless * it has already been found. Then it retries FingerUser, readying a report * and signalling when it's ready to ReportScores each time. After the fingers * are done it cleans up the buffer. */static void RetryFinger(int userIndex, int hostIndex){    Username name;    int address, numRetries, fingerResult;        SemaphoreWait(sweetHosts.array[hostIndex].lock);    if (sweetHosts.array[hostIndex].address == 0) {        SemaphoreWait(sweetHosts.request.lock);        strcpy(sweetHosts.request.name, sweetHosts.array[hostIndex].name);        SemaphoreSignal(sweetHosts.request.ready);        SemaphoreWait(sweetHosts.request.done);        sweetHosts.array[hostIndex].address = sweetHosts.request.address;        SemaphoreSignal(sweetHosts.request.lock);    }    address = sweetHosts.array[hostIndex].address;    if (address != NOT_FOUND && sweetHosts.array[hostIndex].numFailures < UNREACHABLE_THRESHHOLD) {	    SemaphoreSignal(sweetHosts.array[hostIndex].lock);	    SemaphoreWait(sweetUsers.buffer[userIndex].lock);	    strcpy(name, sweetUsers.buffer[userIndex].name);	    SemaphoreSignal(sweetUsers.buffer[userIndex].lock);	    for (numRetries = 0; numRetries < MAX_TRIES; numRetries++) {        	fingerResult = FingerUser(name, address, (numRetries > 0));	        SemaphoreWait(sweetHosts.report.lock);	        sweetHosts.report.hostIndex = hostIndex;	        sweetHosts.report.numRetries = numRetries;	        sweetHosts.report.fingerResult = fingerResult;	        SemaphoreSignal(sweetHosts.report.ready);	        SemaphoreWait(sweetHosts.report.done);	        SemaphoreSignal(sweetHosts.report.lock);	        if (fingerResult != NET_ERR) break;	    }	} else {	    SemaphoreSignal(sweetHosts.array[hostIndex].lock);	}		SemaphoreWait(sweetUsers.buffer[userIndex].lock);	if (--sweetUsers.buffer[userIndex].numThreads == 0) {		// last thread using buffer	    sweetUsers.buffer[userIndex].state = empty;	    SemaphoreSignal(sweetUsers.empty);		SemaphoreSignal(sweetUsers.done);						// add to finished count	}	SemaphoreSignal(sweetUsers.buffer[userIndex].lock);    SemaphoreSignal(threadFree);}/*  * FingerUser * ---------- * The code here obtains a socket, fingers the user, and releases the socket. */static int FingerUser(char *username, int address, bool isRetry){    int socketIndex, fingerResult;        SemaphoreWait(sweetSocket.free);    for (socketIndex = 0; socketIndex < MAX_SOCKETS; socketIndex++) {        SemaphoreWait(sweetSocket.array[socketIndex].lock);        if (sweetSocket.array[socketIndex].busy) {            SemaphoreSignal(sweetSocket.array[socketIndex].lock);        } else {            sweetSocket.array[socketIndex].busy = true;            SemaphoreSignal(sweetSocket.array[socketIndex].lock);            break;        }    }    assert(socketIndex < MAX_SOCKETS);        fingerResult = SendFingerRequest(username, address, socketIndex, isRetry);        SemaphoreWait(sweetSocket.array[socketIndex].lock);    sweetSocket.array[socketIndex].busy = false;    SemaphoreSignal(sweetSocket.array[socketIndex].lock);	SemaphoreSignal(sweetSocket.free);    return fingerResult;}/*  * ReportScores * ------------ * The code here waits for score reports, increments numLogins on success * and numFailures on failed requests. Every once in a while it calls  * PrintReport, and when the final flag is set it calls it once more. */static void ReportScores(void){    int hostIndex, numRetries, fingerResult, totalRequests = 0, failedRequests = 0;        while (SemaphoreWait(sweetHosts.report.ready), !sweetHosts.report.final) {	    hostIndex = sweetHosts.report.hostIndex;	    numRetries = sweetHosts.report.numRetries;	    fingerResult = sweetHosts.report.fingerResult;	    if (fingerResult != NET_ERR) {	        SemaphoreWait(sweetHosts.array[hostIndex].lock);	        sweetHosts.array[hostIndex].numLogins += fingerResult;	        SemaphoreSignal(sweetHosts.array[hostIndex].lock);	    } else {	        failedRequests++;		    if (numRetries == MAX_TRIES-1) {		        SemaphoreWait(sweetHosts.array[hostIndex].lock);		        sweetHosts.array[hostIndex].numFailures++;		        SemaphoreSignal(sweetHosts.array[hostIndex].lock);		    }	    }    	if (++totalRequests % RESULTS_EVERY == 0) {    		PrintReport(totalRequests, failedRequests, false);    	}    	SemaphoreSignal(sweetHosts.report.done);	}	PrintReport(totalRequests, failedRequests, true);	SemaphoreSignal(sweetHosts.report.done);    SemaphoreSignal(threadFree);}/*  * PrintReport * ----------- * The code here prints the scoreboard and the final results. */static void PrintReport(int totalRequests, int failedRequests, bool final){	int hostIndex, total = 0, badCount = 0, goodRequests;    Host tempHosts[MAX_HOSTS];        memcpy(tempHosts, sweetHosts.array, sweetHosts.numHosts * sizeof(Host));    qsort(tempHosts, sweetHosts.numHosts, sizeof(Host), HostCompare);    printf("\n------- Hostname ---- Count ---- (%5d requests completed) ----\n", totalRequests);    for (hostIndex = 0; hostIndex < sweetHosts.numHosts; hostIndex++) {    	if (tempHosts[hostIndex].numLogins > 0) {    		total += tempHosts[hostIndex].numLogins;    		printf("\t%-12s%5d\n", tempHosts[hostIndex].name, tempHosts[hostIndex].numLogins);   		}   	}    printf("\t%-12s%5d\n", "TOTAL", total);    printf("\n  [Unreachable hosts:"); 	for (hostIndex = 0; hostIndex < sweetHosts.numHosts; hostIndex++) {   		if (tempHosts[hostIndex].numFailures >= UNREACHABLE_THRESHHOLD) {   			badCount++;   			printf(" %s", tempHosts[hostIndex].name);   		}   	}   	if (badCount == 0) {   		printf(" none");   	}   	printf("]\n");    printf("----------------------------------------------------------------\n\n\n");    if (final) {    	goodRequests = totalRequests - failedRequests;    	printf("%d requests made, %d successful (%d%% success rate)\n",    		totalRequests, goodRequests, (goodRequests * 100 / totalRequests));    	printf("All done!\n");    }}/*  * HostCompare * ----------- * The code here compares hosts. */static int HostCompare(const void *entry1, const void *entry2){    Host    *h1 = (Host *)entry1,             *h2 = (Host *)entry2;     if (h1->numLogins < h2->numLogins) return +1;    if (h1->numLogins > h2->numLogins) return -1;    return strcasecmp(h1->name, h2->name);}